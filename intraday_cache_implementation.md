# 分时图缓存功能实现说明

## 功能概述

为了解决非交易时间分时图无法显示的问题，我们实现了一个完整的分时图缓存系统。该系统会在每个交易日的收盘时间（15:05）自动缓存所有股票的分时图数据，确保在非交易时间也能正常显示分时图。

## 实现方案

### 1. 缓存管理器扩展 (cache_manager.py)

#### 新增方法：
- `get_intraday_cache_file_path(stock_code, date=None)`: 生成分时图缓存文件路径
- `save_intraday_data(stock_code, data)`: 保存分时图数据到缓存
- `load_intraday_data(stock_code, date=None)`: 从缓存加载分时图数据
- `cleanup_old_intraday_cache()`: 清理过期的分时图缓存文件

#### 缓存文件组织结构：
```
cache/
├── intraday/
│   ├── 000001/
│   │   ├── 2025-02-02.json
│   │   ├── 2025-02-03.json
│   │   └── ...
│   ├── 000002/
│   │   ├── 2025-02-02.json
│   │   └── ...
│   └── ...
```

### 2. 后端API修改 (app.py)

#### 分时图API增强 (`get_stock_intraday_data`)：
- **交易时间**：获取实时数据并自动保存到缓存
- **非交易时间**：优先从缓存读取数据
- **缓存失效**：如果缓存无数据，生成基于最新收盘价的模拟数据

#### 新增定时任务：
- `auto_cache_intraday_data()`: 自动缓存分时图数据
- 定时执行：工作日下午15:05自动执行
- 批量处理：分批处理所有股票，避免API频率限制

#### 新增API接口：
- `POST /api/scheduler/trigger_intraday_cache`: 手动触发分时图缓存任务

### 3. 前端显示优化 (stock_detail.html)

#### 新增功能：
- `showIntradaySimulatedNotice()`: 显示模拟数据提示
- `hideIntradaySimulatedNotice()`: 隐藏模拟数据提示
- `displayIntradayChart(data, isSimulated=false)`: 支持模拟数据标记

#### 用户体验改进：
- 缓存数据显示："从缓存加载X条分时数据"
- 模拟数据提示："非交易时间，显示基于收盘价的模拟分时数据"
- 实时数据标记："成功获取X条分时数据"

## 技术特性

### 1. 智能缓存策略
- **自动保存**：交易时间获取实时数据时自动保存
- **定时缓存**：每日15:05批量缓存所有股票数据
- **数据验证**：确保缓存数据为当日数据
- **过期清理**：自动清理过期的缓存文件

### 2. 数据处理优化
- **完整数据**：包含价格、成交量、VWAP、均价线等完整信息
- **时间过滤**：只保留交易时间段的数据
- **累计计算**：正确计算累计成交量、成交额等指标

### 3. 错误处理机制
- **多级降级**：实时数据 → 缓存数据 → 模拟数据
- **异常恢复**：单个股票失败不影响整体缓存任务
- **日志记录**：详细的操作日志便于问题排查

### 4. 性能优化
- **批量处理**：分批处理股票，避免API频率限制
- **并发控制**：使用文件锁确保缓存数据一致性
- **内存管理**：及时释放大数据对象

## 使用场景

### 1. 交易时间
- 用户访问分时图 → 获取实时数据 → 自动保存到缓存 → 显示实时图表

### 2. 非交易时间
- 用户访问分时图 → 从缓存读取数据 → 显示缓存图表（标记为缓存数据）

### 3. 缓存失效时
- 用户访问分时图 → 缓存无数据 → 生成模拟数据 → 显示模拟图表（标记为模拟数据）

### 4. 定时缓存
- 每日15:05 → 自动获取所有股票分时数据 → 批量保存到缓存 → 清理过期缓存

## 配置说明

### 定时任务配置
```python
# 工作日下午3:05执行分时图数据缓存
schedule.every().monday.at("15:05").do(auto_cache_intraday_data)
schedule.every().tuesday.at("15:05").do(auto_cache_intraday_data)
schedule.every().wednesday.at("15:05").do(auto_cache_intraday_data)
schedule.every().thursday.at("15:05").do(auto_cache_intraday_data)
schedule.every().friday.at("15:05").do(auto_cache_intraday_data)
```

### 缓存参数配置
- **批处理大小**：每批处理5只股票
- **等待时间**：批次间等待12秒
- **缓存保留期**：与主缓存系统一致（90天）

## 测试方法

### 1. 手动触发缓存
```bash
curl -X POST http://localhost:8080/api/scheduler/trigger_intraday_cache
```

### 2. 验证缓存文件
```bash
ls -la cache/intraday/000001/
```

### 3. 测试API响应
```bash
curl http://localhost:8080/api/stock/000001/intraday
```

## 预期效果

1. **用户体验提升**：非交易时间也能正常查看分时图
2. **数据完整性**：保留完整的交易日分时数据
3. **系统稳定性**：减少对外部API的依赖
4. **性能优化**：缓存数据响应更快

## 注意事项

1. **存储空间**：大量股票的分时数据会占用较多磁盘空间
2. **API限制**：需要合理控制AkShare API调用频率
3. **数据时效性**：缓存数据可能不是最新的实时数据
4. **错误处理**：需要处理网络异常、API限制等各种异常情况

## 后续优化方向

1. **增量更新**：只缓存新增的分时数据点
2. **压缩存储**：对缓存数据进行压缩以节省空间
3. **分布式缓存**：支持Redis等分布式缓存系统
4. **实时推送**：结合WebSocket实现实时数据推送